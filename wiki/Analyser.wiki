#summary Guide on how to add an analyser to AARAE.

= Introduction =

An analyser in AARAE primarily aims to provide user-readable output, for example in the form of a visualisation, numeric data. An analyser can also provide auralization or sonification, but in some cases it may be better as a processor rather than an analyser (if the audio content of the auralization/sonification is the main purpose of the function).


= Analyser Inputs =

The inputs to an analyser are likely to include audio data, metadata (e.g. sampling rate), and user-controlled settings for the analyser.

== Audio Data and Metadata ==

Audio data and metadata in AARAE is kept within a structure. An analyser for AARAE should have this structure as its first input argument.

The currently available fields within this structure include:

|| *Field* || * Description and comment* ||
|| .audio || this contains the audio waveform, descending in time down the columns. Dimension 2 is used for channels, and dimension 3 is used for bands (e.g. octave-band filtered data). Analysers should be written to anticipate a potentially 3-dimensional waveform matrix, rather than returning an error if the input is multi-channel and/or multi-band. ||
|| .fs || this is the audio sampling rate in Hz. ||
|| .bands || this is a list of frequencies (or numbers of some type) associated with each band. ||
|| .chans || this is a list of channel identifiers (e.g. angles in the case of beam-formed audio) - which has not been implemented yet. ||
|| .cal || this is a calibration offset in decibels such that 10*log10(wave.^2)+cal yields the appropriate level (e.g., sound pressure level). ||

It is best practice to write an analyser function to accept structure input, as well accepting as a set of discrete input arguments (which can be more convenient if the function is not being called via the GUI). This can be achieved using an isstruct() test, for example:

{{{
function dosomething(in, fs, cal)
if instruct(in)
       audio = in.audio; % audio wave data
       fs = in.fs; % audio sampling rate in Hz
      cal = in.cal; % calibration offset in dB
else
       audio = in;
end
% then do something with the data and metadata ...
}}}

In the above example, the second and third input arguments are ignored if the first input argument is a structure. However if the first input argument is a vector or matrix, it will be used directly as the audio waveform, and the second and third input arguments are required (notwithstanding further code to set default values).

Considering that the audio waveform might be 1, 2 or 3-dimensional, it may be important to be able to read its size. The following code provides this information:

{{{
S = size(audio); % size of the audio matrix
ndim = length(S); % number of dimensions
switch ndim
    case 1
        len = S(1); % number of samples in audio
        chans = 1; % number of channels
        bands = 1; % number of bands
    case 2
        len = S(1); % number of samples in audio
        chans = S(2); % number of channels
        bands = 1; % number of bands
    case 3
        len = S(1); % number of samples in audio
        chans = S(2); % number of channels
        bands = S(3); % number of bands
end
}}}

Having obtained this information, we then need to decide what to do with it. Some analysers will work perfectly well on any number of channels and bands, while others may be designed only for 1 channel, 2 channels, 1 band, or some other constraints. One option is to return an error if the input is incorrectly dimensioned. Another option is to truncate and/or mix the data as required. For example:

{{{
audio = mean(audio,3); % mix all bands together (removing the third dimension)
disp('Multiband audio has been mixed into a single band.')
}}}

or

{{{
if chans > 2
       audio = audio(:,1:2,:); % use only the first two channels
       disp('Only the first two channels have been used.')
end
}}}